<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Meme Wolf Tap</title>
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-database.js"></script>

    <style>
        /* --- Global Styles & Reset --- */
        :root {
            /* ... (keep all :root variables from previous version) ... */
            --primary-bg-start: #1a1a2e; --primary-bg-end: #162447; --secondary-bg: rgba(22, 36, 71, 0.8); --accent-color: #e43f5a; --accent-hover: #c33049; --text-color: #e0e0e0; --text-muted-color: #a0a0a0; --coin-color: #f7b731; --icon-color: #a0a0a0; --icon-active-color: #ffffff; --button-bg-start: #1f4068; --button-bg-end: #2a5a8a; --button-hover-bg-start: #2a5a8a; --button-hover-bg-end: #3b7cb8; --success-color: #4caf50; --warning-color: #ff9800; --error-color: #f44336; --disabled-bg: #444; --disabled-text: #888; --shadow-color: rgba(0, 0, 0, 0.3); --glow-color: rgba(247, 183, 49, 0.6);
            --claimed-color: #5cb85c; /* Green for claimed */
        }

        /* --- (Keep ALL General CSS - body, #app, #loading, page, nav, game screen, shop screen, profile screen, buttons, popups, etc.) --- */
        /* --- Omitted for brevity --- */
        * { box-sizing: border-box; margin: 0; padding: 0; -webkit-tap-highlight-color: transparent; }
        html, body { height: 100%; width: 100%; overflow: hidden; font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif; background: linear-gradient(135deg, var(--primary-bg-start), var(--primary-bg-end)); color: var(--text-color); overscroll-behavior: none; font-size: 16px; }
        body { display: flex; flex-direction: column; touch-action: manipulation; }
        #app { display: flex; flex-direction: column; height: 100%; width: 100%; overflow: hidden; }
        #loading { display: flex; justify-content: center; align-items: center; height: 100%; font-size: 1.5em; color: var(--text-color); text-align: center; padding: 20px; }
        #main-content { flex-grow: 1; display: flex; overflow: hidden; }
        .page { width: 100%; height: 100%; display: none; flex-direction: column; flex-grow: 1; overflow-y: auto; -webkit-overflow-scrolling: touch; padding: 20px 15px 85px 15px; scroll-behavior: smooth; }
        .page.active { display: flex; }
        nav { position: fixed; bottom: 0; left: 0; width: 100%; display: flex; justify-content: space-around; align-items: center; background-color: rgba(15, 23, 42, 0.85); border-top: 1px solid var(--accent-color); padding: 8px 0; backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px); z-index: 100; box-shadow: 0 -2px 10px var(--shadow-color); }
        nav button { background: none; border: none; color: var(--icon-color); cursor: pointer; display: flex; flex-direction: column; align-items: center; font-size: 0.7em; padding: 5px 10px; transition: color 0.2s ease; flex-grow: 1; flex-basis: 0; }
        nav button .material-icons { font-size: 26px; margin-bottom: 3px; }
        nav button:hover { color: var(--icon-active-color); }
        nav button.active { color: var(--accent-color); }
        #game-screen { justify-content: space-between; align-items: center; text-align: center; padding-top: 10px; }
        .stats-bar { display: flex; justify-content: space-around; width: 100%; max-width: 350px; margin-bottom: 10px; font-size: 0.85em; color: var(--text-muted-color); background-color: var(--secondary-bg); padding: 8px 10px; border-radius: 10px; box-shadow: 0 1px 3px var(--shadow-color); }
        .stat-item { display: flex; align-items: center; gap: 5px; }
        .stat-item .material-icons { font-size: 16px; color: var(--coin-color); }
        .coin-balance-container { display: flex; align-items: center; justify-content: center; margin-bottom: 15px; }
        #coin-icon-balance { width: 30px; height: 30px; margin-right: 8px; vertical-align: middle; }
        #coin-balance { font-size: 2.2em; font-weight: bold; color: var(--coin-color); text-shadow: 0 0 8px var(--glow-color); }
        .coin-area { flex-grow: 1; display: flex; justify-content: center; align-items: center; width: 100%; margin-bottom: 10px; }
        #coin-container { position: relative; width: clamp(180px, 50vmin, 250px); height: clamp(180px, 50vmin, 250px); cursor: pointer; user-select: none; -webkit-user-drag: none; border-radius: 50%; }
        #coin-image { width: 100%; height: 100%; transition: transform 0.08s ease-out; border-radius: 50%; box-shadow: 0 0 30px var(--glow-color); filter: drop-shadow(0 5px 15px var(--shadow-color)); }
        #coin-container:active #coin-image { transform: scale(0.94); filter: drop-shadow(0 2px 8px var(--shadow-color)); }
        #click-feedback { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; overflow: hidden; z-index: 99; }
        .click-value { position: absolute; font-size: clamp(1.2em, 4vw, 1.8em); font-weight: bold; color: var(--coin-color); user-select: none; pointer-events: none; animation: floatUpFadeOut 1.2s ease-out forwards; white-space: nowrap; text-shadow: 1px 1px 2px rgba(0,0,0,0.5); }
        @keyframes floatUpFadeOut { 0% { opacity: 1; transform: translateY(0) scale(1); } 100% { opacity: 0; transform: translateY(-70px) scale(0.8); } }
        #shop-screen h2, #profile-screen h2, #tasks-screen h2 { text-align: center; margin-bottom: 25px; color: var(--accent-color); font-size: 1.6em; text-shadow: 1px 1px 2px var(--shadow-color); }
        .shop-tabs { display: flex; justify-content: center; margin-bottom: 25px; border-bottom: 1px solid rgba(255, 255, 255, 0.1); position: sticky; top: -20px; background: linear-gradient(135deg, var(--primary-bg-start), var(--primary-bg-end)); padding-top: 15px; z-index: 10; }
        .shop-tabs button { background: none; border: none; color: var(--icon-color); padding: 12px 20px; cursor: pointer; font-size: 1em; font-weight: 500; border-bottom: 3px solid transparent; margin-bottom: -1px; transition: color 0.2s ease, border-color 0.2s ease; }
        .shop-tabs button:hover { color: var(--icon-active-color); }
        .shop-tabs button.active { color: var(--accent-color); border-bottom-color: var(--accent-color); }
        .shop-category { display: none; flex-direction: column; gap: 12px; }
        .shop-category.active { display: flex; }
        .shop-item { background-color: var(--secondary-bg); padding: 15px; border-radius: 10px; display: flex; justify-content: space-between; align-items: center; gap: 12px; box-shadow: 0 3px 8px var(--shadow-color); border: 1px solid rgba(255, 255, 255, 0.05); }
        .shop-item-info { flex-grow: 1; }
        .shop-item-name { font-weight: 600; font-size: 1.05em; margin-bottom: 4px; color: var(--text-color); }
        .shop-item-details { font-size: 0.85em; color: var(--text-muted-color); margin-bottom: 8px; }
        .shop-item-cost { display: flex; align-items: center; gap: 5px; font-weight: bold; color: var(--coin-color); font-size: 0.95em; }
        .shop-item-cost img { width: 16px; height: 16px; }
        .buy-button { background: linear-gradient(135deg, var(--button-bg-start), var(--button-bg-end)); color: var(--text-color); border: none; padding: 10px 18px; border-radius: 8px; cursor: pointer; font-weight: 600; font-size: 0.9em; transition: background 0.2s ease, transform 0.1s ease, box-shadow 0.2s ease; white-space: nowrap; box-shadow: 0 2px 5px rgba(0,0,0, 0.2); }
        .buy-button:hover:not(:disabled) { background: linear-gradient(135deg, var(--button-hover-bg-start), var(--button-hover-bg-end)); box-shadow: 0 4px 8px rgba(0,0,0, 0.3); }
        .buy-button:active:not(:disabled) { transform: scale(0.97); }
        .buy-button:disabled { background: var(--disabled-bg); color: var(--disabled-text); cursor: not-allowed; box-shadow: none; }
        .profile-section { background-color: var(--secondary-bg); padding: 20px; border-radius: 12px; margin-bottom: 20px; box-shadow: 0 4px 10px var(--shadow-color); border: 1px solid rgba(255, 255, 255, 0.05); }
        .profile-info p { margin-bottom: 12px; font-size: 1em; line-height: 1.5; word-break: break-all; display: flex; align-items: center; flex-wrap: wrap; }
        .profile-info p strong { color: var(--coin-color); margin-right: 8px; min-width: 120px; display: inline-block; }
        .profile-info p span { flex-grow: 1; }
        .wallet-section label { display: block; margin-bottom: 10px; font-weight: 600; color: var(--text-muted-color); }
        #ton-wallet-input { width: 100%; padding: 12px; margin-bottom: 15px; border-radius: 8px; border: 1px solid rgba(255, 255, 255, 0.1); background-color: rgba(0, 0, 0, 0.2); color: var(--text-color); font-size: 1em; }
        #save-wallet-button { background: linear-gradient(135deg, var(--accent-color), var(--accent-hover)); color: white; border: none; padding: 12px 20px; border-radius: 8px; cursor: pointer; font-weight: bold; width: 100%; font-size: 1em; transition: background 0.2s ease, transform 0.1s ease; box-shadow: 0 2px 5px rgba(0,0,0, 0.2); }
        #save-wallet-button:hover { background: linear-gradient(135deg, var(--accent-hover), var(--accent-color)); box-shadow: 0 4px 8px rgba(0,0,0, 0.3); }
        #save-wallet-button:active { transform: scale(0.98); }
        #save-status { margin-top: 12px; text-align: center; color: var(--success-color); font-size: 0.9em; height: 1.2em; font-weight: 500; }
        .mission-section { text-align: center; }
        .mission-title { font-size: 1.2em; font-weight: 600; margin-bottom: 10px; color: var(--text-color); }
        .mission-description { font-size: 0.95em; color: var(--text-muted-color); margin-bottom: 15px; line-height: 1.5; }
        .mission-emoji { font-size: 2em; margin: 0 5px; display: inline-block; cursor: default; }
        .copy-emoji-button { background: none; border: 1px solid var(--accent-color); color: var(--accent-color); padding: 5px 10px; font-size: 0.8em; border-radius: 5px; cursor: pointer; margin-left: 10px; transition: background-color 0.2s ease, color 0.2s ease; }
        .copy-emoji-button:hover { background-color: var(--accent-color); color: white; }
        .mission-status { font-weight: bold; margin: 15px 0; font-size: 1em; }
        .mission-status.incomplete { color: var(--text-muted-color); }
        .mission-status.claimed { color: var(--coin-color); }
        .mission-action-button { background: linear-gradient(135deg, var(--button-bg-start), var(--button-bg-end)); color: var(--text-color); border: none; padding: 10px 25px; border-radius: 8px; cursor: pointer; font-weight: 600; font-size: 0.95em; transition: background 0.2s ease, transform 0.1s ease, box-shadow 0.2s ease; box-shadow: 0 2px 5px rgba(0,0,0, 0.2); }
        .mission-action-button:hover:not(:disabled) { background: linear-gradient(135deg, var(--button-hover-bg-start), var(--button-hover-bg-end)); box-shadow: 0 4px 8px rgba(0,0,0, 0.3); }
        .mission-action-button:active:not(:disabled) { transform: scale(0.97); }
        .mission-action-button:disabled { background: var(--disabled-bg); color: var(--disabled-text); cursor: not-allowed; box-shadow: none; }
        .reward-display { display: flex; align-items: center; justify-content: center; gap: 5px; font-weight: bold; color: var(--coin-color); margin-top: 5px; }
        .fine-applied { color: var(--error-color); font-weight: bold; margin-top: 10px; font-size: 0.9em; }
        .coin-icon { width: 1em; height: 1em; vertical-align: middle; margin: 0 2px; }
        @keyframes shake { 10%, 90% { transform: translate3d(-1px, 0, 0); } 20%, 80% { transform: translate3d(2px, 0, 0); } 30%, 50%, 70% { transform: translate3d(-3px, 0, 0); } 40%, 60% { transform: translate3d(3px, 0, 0); } }


        /* --- Tasks Screen CSS --- */
        #tasks-list {
            display: flex;
            flex-direction: column;
            gap: 15px; /* Space between task items */
        }

        .task-item {
            background-color: var(--secondary-bg);
            padding: 15px;
            border-radius: 10px;
            display: flex;
            align-items: center; /* Vertically align items */
            gap: 15px; /* Space between image, info, button */
            box-shadow: 0 3px 8px var(--shadow-color);
            border: 1px solid rgba(255, 255, 255, 0.05);
            transition: opacity 0.3s ease;
        }

        .task-item.claimed-visual { /* Style for completed tasks */
             opacity: 0.7;
             border-left: 5px solid var(--claimed-color);
         }

        .task-image {
            width: 50px;
            height: 50px;
            border-radius: 8px;
            object-fit: cover; /* Crop image nicely */
            flex-shrink: 0; /* Prevent image from shrinking */
        }
         .task-image.placeholder { /* Style if no image URL provided */
             background-color: var(--disabled-bg);
             display: flex;
             align-items: center;
             justify-content: center;
             font-size: 24px;
             color: var(--text-muted-color);
         }

        .task-info {
            flex-grow: 1; /* Take remaining space */
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .task-name {
            font-weight: 600;
            font-size: 1.1em;
            color: var(--text-color);
        }

        .task-description {
            font-size: 0.9em;
            color: var(--text-muted-color);
            line-height: 1.4;
        }

        .task-reward {
            display: flex;
            align-items: center;
            gap: 5px;
            font-weight: bold;
            color: var(--coin-color);
            font-size: 0.95em;
            margin-top: 5px;
        }
         .task-reward img { width: 16px; height: 16px; }


        .task-action {
            flex-shrink: 0; /* Prevent button area from shrinking */
        }

        .task-button {
             background: linear-gradient(135deg, var(--button-bg-start), var(--button-bg-end));
             color: var(--text-color);
             border: none;
             padding: 10px 15px;
             border-radius: 8px;
             cursor: pointer;
             font-weight: 600;
             font-size: 0.9em;
             transition: all 0.2s ease;
             white-space: nowrap;
             box-shadow: 0 2px 5px rgba(0,0,0, 0.2);
             min-width: 80px; /* Ensure decent button width */
             text-align: center;
        }
        .task-button:hover:not(:disabled) {
             background: linear-gradient(135deg, var(--button-hover-bg-start), var(--button-hover-bg-end));
             box-shadow: 0 4px 8px rgba(0,0,0, 0.3);
             transform: translateY(-1px);
         }
         .task-button:active:not(:disabled) {
             transform: scale(0.97);
         }

        .task-button.verify-btn { /* Specific style for verify button */
             background: linear-gradient(135deg, var(--warning-color), #ffb74d); /* Orange gradient */
         }
         .task-button.verify-btn:hover:not(:disabled) {
             background: linear-gradient(135deg, #ffb74d, var(--warning-color));
         }


         .task-button.claimed-btn { /* Style for claimed button */
             background: var(--claimed-color);
             color: white;
             cursor: not-allowed;
             box-shadow: none;
             opacity: 0.8;
         }
         .task-button:disabled:not(.claimed-btn) { /* General disabled (e.g., during timer) */
             background: var(--disabled-bg);
             color: var(--disabled-text);
             cursor: not-allowed;
             box-shadow: none;
             opacity: 0.7;
         }

         .task-timer { /* Optional: display timer countdown */
              font-size: 0.8em;
              color: var(--warning-color);
              margin-top: 5px;
              text-align: center;
         }


    </style>
</head>
<body>
    <div id="app">
        <div id="loading">Initializing Meme Wolf...</div>
        <div id="main-content" style="display: none;">
            <!-- Page: Game -->
            <div id="game-screen" class="page active"> /* ... Game Content ... */ </div>
            <!-- Page: Shop -->
            <div id="shop-screen" class="page"> /* ... Shop Content ... */ </div>
             <!-- Page: Tasks -->
             <div id="tasks-screen" class="page">
                 <h2>Daily Tasks</h2>
                 <div id="tasks-list">
                     <!-- Task items will be loaded here -->
                     <p>Loading tasks...</p>
                 </div>
             </div>
            <!-- Page: Profile -->
            <div id="profile-screen" class="page"> /* ... Profile Content ... */ </div>
        </div>
        <!-- Navigation Bar -->
        <nav id="navbar" style="display: none;">
            <button id="nav-game" class="active" onclick="showPage('game-screen')"><span class="material-icons">pets</span><span>Game</span></button>
            <button id="nav-shop" onclick="showPage('shop-screen')"><span class="material-icons">shopping_bag</span><span>Shop</span></button>
             <button id="nav-tasks" onclick="showPage('tasks-screen')"><span class="material-icons">checklist</span><span>Tasks</span></button> {/* <<< Task Nav Button */}
            <button id="nav-profile" onclick="showPage('profile-screen')"><span class="material-icons">account_circle</span><span>Profile</span></button>
        </nav>
    </div>

    <script>
        // --- Config ---
        // (Keep Firebase Config, Constants like BASE_TAP_EARN, WOLF_EMOJI, etc.)
        const firebaseConfig = { apiKey: "AIzaSyCyH3Z92F8RQweInLC5w_bk_AaLx6XT7UE", authDomain: "ab-wallet-62482.firebaseapp.com", databaseURL: "https://ab-wallet-62482-default-rtdb.firebaseio.com", projectId: "ab-wallet-62482", storageBucket: "ab-wallet-62482.firebasestorage.app", messagingSenderId: "642030839072", appId: "1:642030839072:web:77fc92375ba72e2ee62345" };
        const COIN_IMAGE_URL = "https://preview--ab-wallet-tap-power.lovable.app/lovable-uploads/3a2a084b-4cf2-4293-8e80-3f202d4abe87.png";
        const BASE_TAP_EARN = 1; const SAVE_INTERVAL = 5000; const PASSIVE_INCOME_INTERVAL = 1000; const INCREASING_COST_BASE = 10000; const WOLF_MISSION_REWARD = 50000; const WOLF_EMOJI = 'üê∫'; const CHEAT_FINE = 100000;

        // --- State Vars ---
        let tg = null; let db = null; let currentUser = null; let userData = null;
        let lastSaveTime = 0; let saveTimeout = null; let passiveIncomeIntervalId = null;
        let isLoading = true;
        let availableTasks = {}; // Store fetched task definitions { taskId: taskData }
        let activeLinkTaskTimers = {}; // Store active timers { taskId: { timeoutId: ..., endTime: ... } }

        // --- DOM Elements ---
        // (Keep all previous DOM elements)
        const loadingDiv = document.getElementById('loading'); const mainContentDiv = document.getElementById('main-content'); const navbar = document.getElementById('navbar'); const coinBalanceSpan = document.getElementById('coin-balance'); const tapPowerDisplaySpan = document.getElementById('tap-power-display'); const passiveIncomeDisplaySpan = document.getElementById('passive-income-display'); const coinContainer = document.getElementById('coin-container'); const clickFeedbackDiv = document.getElementById('click-feedback'); const clickUpgradesDiv = document.getElementById('click-upgrades'); const passiveUpgradesDiv = document.getElementById('passive-upgrades'); const profileUserIdSpan = document.getElementById('profile-userid'); const profileUsernameSpan = document.getElementById('profile-username'); const profileFirstNameSpan = document.getElementById('profile-firstname'); const profileLastNameSpan = document.getElementById('profile-lastname'); const profileCoinsSpan = document.getElementById('profile-coins'); const profileTapPowerSpan = document.getElementById('profile-tap-power'); const profilePassiveIncomeSpan = document.getElementById('profile-passive-income'); const tonWalletInput = document.getElementById('ton-wallet-input'); const saveWalletButton = document.getElementById('save-wallet-button'); const saveStatusP = document.getElementById('save-status'); const missionEmojiDisplay = document.getElementById('mission-emoji-display'); const copyEmojiBtn = document.getElementById('copy-emoji-btn'); const missionStatusDiv = document.getElementById('mission-status'); const missionClaimBtn = document.getElementById('mission-claim-btn'); const fineMessageDisplay = document.getElementById('fine-message-display');
        const tasksListDiv = document.getElementById('tasks-list'); // <<< Task List Container
        const navButtons = document.querySelectorAll('nav button'); const shopTabButtons = document.querySelectorAll('.shop-tabs button'); const shopCategories = document.querySelectorAll('.shop-category');


        // --- Upgrade Definitions (Keep full list) ---
        const upgrades = [ /* Omitted for brevity - paste the full upgrades array here */ ];

        // --- Initialization ---
        window.onload = () => {
             try {
                 isLoading = true;
                 loadingDiv.textContent = "Initializing Meme Wolf...";
                 tg = window.Telegram.WebApp;
                 tg.ready();
                 tg.expand();
                 try { const bgColor = getComputedStyle(document.documentElement).getPropertyValue('--primary-bg-end').trim(); tg.setHeaderColor(bgColor); tg.setBackgroundColor(bgColor); } catch (themeError) { console.warn("Could not set theme colors:", themeError); }

                 if (!tg.initDataUnsafe || !tg.initDataUnsafe.user) { loadingDiv.textContent = "Error: User data unavailable. Please launch from Telegram."; loadingDiv.style.color = 'var(--error-color)'; console.error("Critical: Telegram user data missing."); return; }
                 currentUser = tg.initDataUnsafe.user;

                 firebase.initializeApp(firebaseConfig);
                 db = firebase.database();

                 // Chain loading: User Data -> Tasks -> Init App
                 loadUserDataAndInitTasks();
                 setupEventListeners();

             } catch (error) {
                 console.error("Critical Initialization Error:", error);
                 showError(`Initialization failed: ${error.message}. Please try reloading.`);
             }
         };

        // --- Popup Helpers (Keep) ---
        function showPopup(params) { /* ... same ... */ }
        function showInfoPopup(title, message) { /* ... same ... */ }
        function showWarningPopup(title, message) { /* ... same ... */ }
        function showRewardPopup(title, message) { /* ... same ... */ }


        // --- Firebase Functions ---
        function loadUserDataAndInitTasks() {
             // 1. Load User Data
             if (!currentUser || !db) { showError("User/DB not ready."); return; }
             const userId = currentUser.id.toString();
             const userRef = db.ref('users/' + userId);
             loadingDiv.textContent = "Loading your progress...";

             userRef.once('value')
                 .then(snapshot => {
                     // Process user data (ensure tasksCompleted exists)
                     const defaultData = { coins: 0, upgrades: {}, missions: { lastNameWolf: 'incomplete' }, tasksCompleted: {}, /* <<< Initialize */ tonWallet: '', lastUpdate: Date.now(), telegramInfo: { /*...*/ } };
                     if (snapshot.exists()) {
                         userData = snapshot.val();
                         // Merge defaults robustly
                         userData.coins = userData.coins ?? defaultData.coins; userData.upgrades = userData.upgrades ?? defaultData.upgrades; userData.missions = userData.missions ?? defaultData.missions; userData.missions.lastNameWolf = userData.missions.lastNameWolf ?? defaultData.missions.lastNameWolf;
                         userData.tasksCompleted = userData.tasksCompleted ?? defaultData.tasksCompleted; // <<< Ensure exists
                         userData.tonWallet = userData.tonWallet ?? defaultData.tonWallet; userData.lastUpdate = userData.lastUpdate ?? defaultData.lastUpdate; userData.telegramInfo = { id: currentUser.id, username: currentUser.username || null, firstName: currentUser.first_name || '', lastName: currentUser.last_name || '' };
                     } else {
                         console.log("New user detected:", userId);
                         userData = defaultData;
                         saveUserData(true);
                     }

                      // Perform Anti-Cheat Check (modifies userData potentially)
                     const cheatDetected = performAntiCheatCheck();
                     // Calculate Offline Progress (AFTER anti-cheat)
                     if (!cheatDetected) { calculateOfflineProgress(); } else { userData.lastUpdate = Date.now(); }


                     // 2. Fetch Tasks AFTER user data is loaded
                     return fetchAllTasks(); // Chain the promise
                 })
                 .then(() => {
                     // 3. Final Initialization (Tasks are now in availableTasks)
                     initializeAppUI();
                     startPassiveIncome();
                     isLoading = false;
                     console.log("App Initialized Successfully.");
                 })
                 .catch(error => {
                      // Robust Error Handling
                      console.error("------------------------------------"); console.error("Firebase Load Error (User or Tasks):"); console.error("Full Error Object:", error); console.error("Error Code:", error?.code); console.error("Error Message:", error?.message); console.error("------------------------------------");
                      let displayMessage = `Failed to load data. Please check connection and reload.`;
                      if (error?.code) { displayMessage += ` (Code: ${error.code})`; }
                      if (String(error).includes('WebAppPopupOpened')) { console.warn("Suppressed 'WebAppPopupOpened' from user display."); }
                      showError(displayMessage);
                      isLoading = false;
                 });
         }

        function fetchAllTasks() {
             console.log("Fetching tasks from Firebase...");
             loadingDiv.textContent = "Loading available tasks...";
             return db.ref('tasks').once('value')
                 .then(snapshot => {
                     if (snapshot.exists()) {
                         availableTasks = snapshot.val();
                         console.log("Tasks loaded:", Object.keys(availableTasks).length);
                     } else {
                         console.warn("No tasks found in Firebase '/tasks' node.");
                         availableTasks = {};
                     }
                 })
                 .catch(error => {
                     console.error("Firebase Task Fetch Error:", error);
                     availableTasks = {}; // Ensure it's an empty object on error
                     // Optional: Propagate error or show specific task loading error
                     // showError("Could not load tasks. Some features might be unavailable.");
                     throw error; // Re-throw to be caught by the main chain's catch block
                 });
         }


        function saveUserData(force = false) {
             // (Keep previous saveUserData logic, ensures tasksCompleted is saved)
             if (isLoading || !currentUser || !db || !userData) return; const now = Date.now(); userData.lastUpdate = now; clearTimeout(saveTimeout); if (force || now - lastSaveTime > SAVE_INTERVAL) { console.log("Saving data..."); const userId = currentUser.id.toString(); userData.telegramInfo = { id: currentUser.id, username: currentUser.username || null, firstName: currentUser.first_name || '', lastName: currentUser.last_name || '' }; db.ref('users/' + userId).set(userData).then(() => { console.log("Data saved."); lastSaveTime = now; }).catch((error) => console.error("Firebase Save Error:", error)); } else { saveTimeout = setTimeout(() => saveUserData(true), SAVE_INTERVAL - (now - lastSaveTime)); }
        }

        // --- Anti-Cheat Logic (Keep) ---
        function performAntiCheatCheck() { /* ... same as before ... */ if (!userData || !currentUser) return false; const missionId = 'lastNameWolf'; const missionStatus = userData.missions?.[missionId]; const currentLastName = currentUser.last_name || ''; fineMessageDisplay.style.display = 'none'; if (missionStatus === 'claimed' && !currentLastName.endsWith(WOLF_EMOJI)) { const fineAmount = CHEAT_FINE; userData.coins = Math.max(0, userData.coins - fineAmount); userData.missions[missionId] = 'incomplete'; console.warn(`Anti-cheat triggered for user ${currentUser.id}. Fine: ${fineAmount}`); showWarningPopup("üö® Cheating Detected!", `You removed the ${WOLF_EMOJI} emoji after claiming the reward!\nA fine of ${formatNumber(fineAmount)} coins has been applied. Add the emoji back to complete the mission (no second reward).`); fineMessageDisplay.textContent = `Fine Applied: -${formatNumber(fineAmount)} coins for removing emoji.`; fineMessageDisplay.style.display = 'block'; return true; } return false; }

        // --- Game Logic (Keep: handleTap, calculates, applyPassive, startPassive, scheduleSave) ---
        // ... (handleTap, calculateTapPower, calculatePassiveIncomeRate, applyPassiveIncome, startPassiveIncome, scheduleSave are the same) ...
        function handleTap(event) { if (isLoading || !userData) return; const tapValue = calculateTapPower(); userData.coins += tapValue; let clientX, clientY; if (event.touches && event.touches.length > 0) { for (let i = 0; i < event.touches.length; i++) { clientX = event.touches[i].clientX; clientY = event.touches[i].clientY; createClickAnimation(clientX, clientY, tapValue); } } else { clientX = event.clientX; clientY = event.clientY; createClickAnimation(clientX, clientY, tapValue); } updateCoinDisplay(); scheduleSave(); }
        function calculateTapPower() { let power = BASE_TAP_EARN; if (userData && userData.upgrades) { for (const upgradeId in userData.upgrades) { const upgradeDef = upgrades.find(u => u.id === upgradeId); if (upgradeDef && upgradeDef.type === 'click') { const level = userData.upgrades[upgradeId]?.level || 0; power += upgradeDef.baseEffect * level; } } } return power; }
        function calculatePassiveIncomeRate() { let rate = 0; if (userData && userData.upgrades) { for (const upgradeId in userData.upgrades) { const upgradeDef = upgrades.find(u => u.id === upgradeId); if (upgradeDef && upgradeDef.type === 'passive') { const level = userData.upgrades[upgradeId]?.level || 0; rate += upgradeDef.baseEffect * level; } } } return rate; }
        function applyPassiveIncome() { if (isLoading || !userData) return; const hourlyRate = calculatePassiveIncomeRate(); const incomePerTick = hourlyRate / 3600 * (PASSIVE_INCOME_INTERVAL / 1000); if (incomePerTick > 0) { userData.coins += incomePerTick; updateCoinDisplay(); } }
        function startPassiveIncome() { if (passiveIncomeIntervalId) clearInterval(passiveIncomeIntervalId); passiveIncomeIntervalId = setInterval(applyPassiveIncome, PASSIVE_INCOME_INTERVAL); }
        function scheduleSave() { saveUserData(); }

        function calculateOfflineProgress() {
             // (Keep previous logic with popup helper)
             if (!userData || !userData.lastUpdate) return; const now = Date.now(); const offlineSeconds = Math.max(0, Math.floor((now - userData.lastUpdate) / 1000)); if (offlineSeconds < 10) return; const hourlyRate = calculatePassiveIncomeRate(); const offlineIncome = (hourlyRate / 3600) * offlineSeconds; if (offlineIncome > 0) { userData.coins += offlineIncome; console.log(`Offline income: ${formatNumber(offlineIncome)} coins for ${offlineSeconds}s.`); showRewardPopup("Welcome Back!", `You earned ${formatNumber(offlineIncome)} ${WOLF_EMOJI} coins while away!`); }
        }

        // --- Mission Logic (Keep: checkAndClaimMission, copyMissionEmoji) ---
        // ... (checkAndClaimMission, copyMissionEmoji are the same) ...
        function checkAndClaimMission() { if (isLoading || !userData || !currentUser) return; const missionId = 'lastNameWolf'; const currentStatus = userData.missions?.[missionId] || 'incomplete'; const lastName = currentUser.last_name || ''; if (currentStatus === 'claimed') { showInfoPopup("Mission Status", "You have already claimed the reward for this mission."); updateMissionUI(missionId, 'claimed', false); return; } const isConditionMet = lastName.endsWith(WOLF_EMOJI); if (isConditionMet) { userData.coins += WOLF_MISSION_REWARD; userData.missions[missionId] = 'claimed'; console.log(`Mission '${missionId}' claimed. Reward: ${WOLF_MISSION_REWARD}`); showRewardPopup("Mission Complete!", `Well done! You earned ${formatNumber(WOLF_MISSION_REWARD)} coins for adding the ${WOLF_EMOJI} to your name!`); updateMissionUI(missionId, 'claimed', false); updateCoinDisplay(); updateProfileStats(); saveUserData(true); } else { updateMissionUI(missionId, 'incomplete', false); showInfoPopup("Mission Incomplete", `Make sure the ${WOLF_EMOJI} emoji is at the very end of your Telegram Last Name, then try checking again.`); } }
        function copyMissionEmoji() { navigator.clipboard.writeText(WOLF_EMOJI).then(() => { copyEmojiBtn.textContent = 'Copied!'; setTimeout(() => { copyEmojiBtn.textContent = 'Copy Emoji'; }, 1500); }).catch(err => { console.error('Failed to copy emoji: ', err); }); }


        // --- Task Logic ---
        function fetchAndRenderTasks() {
            if (isLoading || !userData) {
                 tasksListDiv.innerHTML = '<p>Loading user data first...</p>';
                 return;
            }
            tasksListDiv.innerHTML = ''; // Clear previous tasks

            if (!availableTasks || Object.keys(availableTasks).length === 0) {
                 tasksListDiv.innerHTML = '<p>No tasks available right now. Check back later!</p>';
                 return;
             }

            // Sort tasks maybe? (e.g., incomplete first)
            const taskIds = Object.keys(availableTasks);
            // Example sort: incomplete first, then by original order (or add a 'sortOrder' field in Firebase)
            taskIds.sort((a, b) => {
                const completedA = userData.tasksCompleted?.[a] === true;
                const completedB = userData.tasksCompleted?.[b] === true;
                if (completedA === completedB) return 0; // Keep original relative order if same status
                return completedA ? 1 : -1; // Incomplete first (-1)
            });


            let hasVisibleTasks = false;
            taskIds.forEach(taskId => {
                 const taskData = availableTasks[taskId];
                 if (taskData && taskData.isActive === true) { // Only render active tasks
                    renderTaskItem(taskId, taskData);
                    hasVisibleTasks = true;
                 }
             });

             if (!hasVisibleTasks) {
                 tasksListDiv.innerHTML = '<p>No active tasks available right now.</p>';
             }
        }

        function renderTaskItem(taskId, taskData) {
             const isCompleted = userData.tasksCompleted?.[taskId] === true;
             const taskItem = document.createElement('div');
             taskItem.className = `task-item ${isCompleted ? 'claimed-visual' : ''}`;
             taskItem.id = `task-${taskId}`;

             // Image or Placeholder
             let imageHtml = '';
             if (taskData.imageUrl) {
                 imageHtml = `<img src="${taskData.imageUrl}" alt="${taskData.name}" class="task-image">`;
             } else {
                 // Simple placeholder with first letter
                 const placeholderLetter = taskData.name ? taskData.name.charAt(0).toUpperCase() : '?';
                 imageHtml = `<div class="task-image placeholder">${placeholderLetter}</div>`;
             }

             // Button generation
             let buttonHtml = '';
             let timerHtml = ''; // Placeholder for timer display

             if (isCompleted) {
                 buttonHtml = `<button class="task-button claimed-btn" disabled>Claimed</button>`;
             } else {
                  // Check if a timer is currently active for this task (from sessionStorage)
                  const timerInfo = activeLinkTaskTimers[taskId];
                  const now = Date.now();

                 if (taskData.type === 'link' && timerInfo && now < timerInfo.endTime) {
                     // Timer is running for this link task
                     buttonHtml = `<button class="task-button verify-btn" onclick="handleTaskAction('${taskId}')" disabled>Verify</button>`; // Initially disabled
                     // Start interval to update timer display and enable button when done
                     startTimerDisplay(taskId, timerInfo.endTime);
                 } else if (taskData.type === 'link' && timerInfo && now >= timerInfo.endTime) {
                      // Timer finished, ready to verify
                      buttonHtml = `<button class="task-button verify-btn" onclick="handleTaskAction('${taskId}')">Verify</button>`;
                 }
                 else {
                     // Default state: Start button
                      const buttonText = taskData.type === 'code' ? 'Get Code' : 'Start';
                     buttonHtml = `<button class="task-button start-task-btn" onclick="handleTaskAction('${taskId}')">${buttonText}</button>`;
                 }
             }


             taskItem.innerHTML = `
                 ${imageHtml}
                 <div class="task-info">
                     <div class="task-name">${taskData.name || 'Unnamed Task'}</div>
                     <div class="task-description">${taskData.description || ''}</div>
                     <div class="task-reward">
                         <img src="${COIN_IMAGE_URL}" class="coin-icon" alt="Coin">
                         <span>+${formatNumber(taskData.reward || 0)}</span>
                     </div>
                 </div>
                 <div class="task-action">
                     ${buttonHtml}
                     <div class="task-timer" id="timer-${taskId}"></div> {/* Timer display area */}
                 </div>
             `;
             tasksListDiv.appendChild(taskItem);
         }

        function handleTaskAction(taskId) {
            if (isLoading || !userData) return;
            const taskData = availableTasks[taskId];
            if (!taskData) { console.error("Task data not found for:", taskId); return; }

            const isCompleted = userData.tasksCompleted?.[taskId] === true;
            if (isCompleted) return; // Do nothing if already claimed

            const taskButton = document.querySelector(`#task-${taskId} .task-button`);

            if (taskData.type === 'link') {
                const timerInfo = activeLinkTaskTimers[taskId];
                const now = Date.now();
                 // If button is 'Verify' (meaning timer exists or just finished)
                 if (taskButton && taskButton.classList.contains('verify-btn')) {
                     if (timerInfo && now >= timerInfo.endTime) {
                         verifyLinkTask(taskId, taskData);
                     } else {
                         showInfoPopup("Wait!", "Please wait for the timer to finish before verifying.");
                     }
                 } else { // Button is 'Start'
                     startLinkTask(taskId, taskData);
                 }

            } else if (taskData.type === 'code') {
                startCodeTask(taskId, taskData);
            }
        }

         function startTimerDisplay(taskId, endTime) {
             const timerDisplay = document.getElementById(`timer-${taskId}`);
             const taskButton = document.querySelector(`#task-${taskId} .task-button`);
             if (!timerDisplay || !taskButton) return;

             // Clear existing interval for this task if any
             if (activeLinkTaskTimers[taskId]?.intervalId) {
                 clearInterval(activeLinkTaskTimers[taskId].intervalId);
             }

             const intervalId = setInterval(() => {
                 const now = Date.now();
                 const timeLeft = Math.max(0, Math.ceil((endTime - now) / 1000));
                 timerDisplay.textContent = `Verify in: ${timeLeft}s`;

                 if (timeLeft <= 0) {
                     clearInterval(intervalId);
                     timerDisplay.textContent = "Ready to Verify!";
                     taskButton.disabled = false; // Enable verify button
                     taskButton.textContent = "Verify";
                     // Update state representation if needed
                     if (activeLinkTaskTimers[taskId]) {
                          delete activeLinkTaskTimers[taskId].intervalId; // Clean up interval ID
                     }
                 } else {
                     taskButton.disabled = true; // Ensure button stays disabled while timer runs
                 }
             }, 1000);

              // Store interval ID to clear it later if needed
             if (activeLinkTaskTimers[taskId]) {
                  activeLinkTaskTimers[taskId].intervalId = intervalId;
             }

             // Initial display update
             const initialTimeLeft = Math.max(0, Math.ceil((endTime - Date.now()) / 1000));
             if(initialTimeLeft > 0) {
                 timerDisplay.textContent = `Verify in: ${initialTimeLeft}s`;
                 taskButton.disabled = true;
                 taskButton.textContent = "Waiting..."; // Change button text while waiting
             } else {
                 // Timer might already be done if page reloaded just right
                 timerDisplay.textContent = "Ready to Verify!";
                 taskButton.disabled = false;
                 taskButton.textContent = "Verify";
                 clearInterval(intervalId); // Stop interval immediately
                 if (activeLinkTaskTimers[taskId]) {
                     delete activeLinkTaskTimers[taskId].intervalId;
                 }
             }
         }


        function startLinkTask(taskId, taskData) {
            console.log(`Starting link task: ${taskId}`);
            const verificationTimeMs = (taskData.verificationTime || 5) * 1000; // Default 5s
            const endTime = Date.now() + verificationTimeMs;

            // Store timer info (use sessionStorage for persistence across refresh within the same session)
            // NOTE: This won't persist if the user closes and reopens the Mini App completely.
            // A more robust solution would store start time in Firebase, but increases complexity/writes.
            activeLinkTaskTimers[taskId] = { endTime: endTime };
             try { sessionStorage.setItem('activeLinkTaskTimers', JSON.stringify(activeLinkTaskTimers)); } catch (e) { console.warn("SessionStorage not available or failed:", e); }

            // Update UI immediately
            const taskButton = document.querySelector(`#task-${taskId} .task-button`);
            const timerDisplay = document.getElementById(`timer-${taskId}`);
            if (taskButton) {
                taskButton.disabled = true;
                taskButton.textContent = 'Waiting...';
                taskButton.classList.remove('start-task-btn');
                taskButton.classList.add('verify-btn'); // Change class to indicate verify state
            }
             if (timerDisplay) {
                 timerDisplay.textContent = `Verify in: ${taskData.verificationTime || 5}s`;
             }

             // Start visual countdown and enable button later
             startTimerDisplay(taskId, endTime);


            // Open the link using Telegram's method
            if (taskData.link) {
                showInfoPopup("Task Started", `Opening the link. Please wait ${taskData.verificationTime || 5} seconds after visiting, then return here and click Verify.`);
                tg.openLink(taskData.link);
            } else {
                 showWarningPopup("No Link", "This task has no link configured. Starting timer anyway.");
            }
        }

         // Function to load timers from sessionStorage on init
         function loadActiveTimers() {
             try {
                 const storedTimers = sessionStorage.getItem('activeLinkTaskTimers');
                 if (storedTimers) {
                     activeLinkTaskTimers = JSON.parse(storedTimers);
                     console.log("Loaded active timers from sessionStorage:", activeLinkTaskTimers);
                     // Potentially re-render tasks or start timer displays if needed after tasks are loaded
                 }
             } catch (e) {
                 console.warn("Failed to load timers from sessionStorage:", e);
                 activeLinkTaskTimers = {};
             }
         }
         // Call this early in the init process, e.g., right after TG init
         // window.onload = () => { ... loadActiveTimers(); ... } // Add this call


        function verifyLinkTask(taskId, taskData) {
            console.log(`Verifying link task: ${taskId}`);
            // Double check time locally (anti-cheat basic)
            const timerInfo = activeLinkTaskTimers[taskId];
            if (!timerInfo || Date.now() < timerInfo.endTime) {
                 showWarningPopup("Not Yet!", "The verification timer hasn't finished yet.");
                 return;
            }

             // Mark as completed in userData
             if (!userData.tasksCompleted) userData.tasksCompleted = {};
             userData.tasksCompleted[taskId] = true;
             userData.coins += taskData.reward || 0;

             // Clean up timer
             delete activeLinkTaskTimers[taskId];
             try { sessionStorage.setItem('activeLinkTaskTimers', JSON.stringify(activeLinkTaskTimers)); } catch (e) { console.warn("SessionStorage clear failed:", e); }


             // Update UI
             const taskItem = document.getElementById(`task-${taskId}`);
             const taskButton = taskItem?.querySelector('.task-button');
             const timerDisplay = document.getElementById(`timer-${taskId}`);

             if (taskItem) taskItem.classList.add('claimed-visual');
             if (taskButton) {
                 taskButton.textContent = 'Claimed';
                 taskButton.disabled = true;
                 taskButton.classList.remove('verify-btn');
                 taskButton.classList.add('claimed-btn');
             }
              if(timerDisplay) timerDisplay.textContent = ''; // Clear timer text

             updateCoinDisplay(); // Update balance display
             showRewardPopup("Task Verified!", `You earned ${formatNumber(taskData.reward || 0)} coins!`);
             saveUserData(true); // Force save
        }

        function startCodeTask(taskId, taskData) {
            console.log(`Starting code task: ${taskId}`);
            // SECURITY WARNING: The correct code (taskData.code) is available in the client's memory here.
            // This is NOT secure for real rewards. A backend check is necessary for production.

            // Optional: Open link first if it exists (e.g., link to where code is found)
            if (taskData.link) {
                showInfoPopup("Find the Code", `Visit the link to find the secret code, then come back here to enter it.`);
                tg.openLink(taskData.link);
                // Give user time before showing prompt, or show prompt immediately? Let's show prompt after info.
                setTimeout(() => showCodeInputPopup(taskId, taskData), 1000); // Short delay after info popup
            } else {
                showCodeInputPopup(taskId, taskData);
            }
        }

        function showCodeInputPopup(taskId, taskData) {
             const promptMessage = `Enter the secret code for the task: "${taskData.name}"`;
             // Using browser's prompt - NOT a native Telegram popup style.
             const enteredCode = prompt(promptMessage);

             if (enteredCode === null) { // User clicked Cancel
                 console.log("Code entry cancelled by user.");
                 return;
             }

             processCodeInput(taskId, taskData, enteredCode.trim());
         }

        function processCodeInput(taskId, taskData, enteredCode) {
             // SECURITY FLAW: Comparing code on client-side.
             const correctCode = taskData.code;

             if (!correctCode) {
                 console.error("Task has type 'code' but no code defined in Firebase:", taskId);
                 showWarningPopup("Task Error", "This task is not configured correctly.");
                 return;
             }

             if (enteredCode === correctCode) {
                  // Mark as completed
                  if (!userData.tasksCompleted) userData.tasksCompleted = {};
                  userData.tasksCompleted[taskId] = true;
                  userData.coins += taskData.reward || 0;

                  // Update UI
                  const taskItem = document.getElementById(`task-${taskId}`);
                  const taskButton = taskItem?.querySelector('.task-button');
                   if (taskItem) taskItem.classList.add('claimed-visual');
                  if (taskButton) {
                      taskButton.textContent = 'Claimed';
                      taskButton.disabled = true;
                       taskButton.classList.remove('start-task-btn');
                      taskButton.classList.add('claimed-btn');
                  }

                  updateCoinDisplay();
                  showRewardPopup("Code Accepted!", `You earned ${formatNumber(taskData.reward || 0)} coins!`);
                  saveUserData(true); // Force save
             } else {
                 // Wrong code
                 showWarningPopup("Incorrect Code", "The code you entered was incorrect. Please try again.");
             }
        }


        // --- UI Functions ---
        function initializeAppUI() {
             // (Initialize all UI elements as before)
             missionEmojiDisplay.textContent = WOLF_EMOJI;
             renderShopItems();
             fetchAndRenderTasks(); // <<< Render tasks now that user data and tasks are loaded
             updateUI(); // Full initial UI render
             loadingDiv.style.display = 'none';
             mainContentDiv.style.display = 'flex';
             navbar.style.display = 'flex';
         }

        function updateUI() {
             if (isLoading || !userData || !currentUser) return;
             updateCoinDisplay(); updateGameStats(); updateShopItemsUI(); updateProfileStats(); updateMissionStatusUI();
             // Could potentially update task list UI here too if needed, but fetchAndRenderTasks handles initial load
             // updateTasksListUI(); // Optional finer-grained update
         }

        // (Keep updateCoinDisplay, updateGameStats, updateProfileStats)
        function updateCoinDisplay() { /* ... */ } function updateGameStats() { /* ... */ } function updateProfileStats() { /* ... */ }

        // (Keep updateMissionStatusUI, updateMissionUI)
        function updateMissionStatusUI() { /* ... */ } function updateMissionUI(missionId, status, isConditionMet) { /* ... */ }

        // (Keep renderShopItems, updateShopItemsUI, handleBuyButtonClick, handleUpgradePurchase, calculateUpgradeCost)
        function renderShopItems() { /* ... */ } function updateShopItemsUI() { /* ... */ } function handleBuyButtonClick(event) { /* ... */ } function handleUpgradePurchase(upgradeId) { /* ... */ } function calculateUpgradeCost(upgradeDef, currentLevel) { /* ... */ }

        // (Keep createClickAnimation)
        function createClickAnimation(x, y, amount) { /* ... */ }

        // --- Navigation ---
        function showPage(pageId) {
             if (isLoading) return;
             document.querySelectorAll('.page').forEach(page => page.classList.remove('active'));
             const targetPage = document.getElementById(pageId);
             if(targetPage) targetPage.classList.add('active');

             navButtons.forEach(button => {
                 button.classList.remove('active');
                  if (button.id === `nav-${pageId.split('-')[0]}`) button.classList.add('active');
             });

             // Refresh data specific to the viewed page
             if (pageId === 'profile-screen') { updateProfileStats(); updateMissionStatusUI(); }
             else if (pageId === 'tasks-screen') { fetchAndRenderTasks(); } // Refresh tasks view

             // scheduleSave(); // Consider if saving on page change is necessary
         }

        // (Keep showShopCategory, saveWallet)
        function showShopCategory(categoryId) { /* ... */ } function saveWallet() { /* ... */ }

        // --- Error Display ---
        function showError(message) {
             const displayMessage = typeof message === 'string' ? message : 'An unknown error occurred. Please try again.';
             loadingDiv.textContent = `Error: ${displayMessage}`; loadingDiv.style.color = 'var(--error-color)'; loadingDiv.style.display = 'flex'; console.error("App Error Displayed:", displayMessage); mainContentDiv.style.display = 'none'; navbar.style.display = 'none'; if (passiveIncomeIntervalId) clearInterval(passiveIncomeIntervalId); isLoading = false;
         }

        // (Keep formatNumber)
        function formatNumber(num) { /* ... */ }

        // --- Event Listeners Setup ---
        function setupEventListeners() {
              // Clear previous listeners to prevent duplicates
              coinContainer.removeEventListener('pointerdown', handleTap);
              saveWalletButton.removeEventListener('click', saveWallet);
              copyEmojiBtn.removeEventListener('click', copyMissionEmoji);
              missionClaimBtn.removeEventListener('click', checkAndClaimMission);
              // Note: Task button listeners are added dynamically in renderTaskItem via onclick

              // Add listeners
              coinContainer.addEventListener('pointerdown', handleTap, { passive: false });
              saveWalletButton.addEventListener('click', saveWallet);
              copyEmojiBtn.addEventListener('click', copyMissionEmoji);
              missionClaimBtn.addEventListener('click', checkAndClaimMission);
              // Load timers from session storage (best effort)
               loadActiveTimers();
         }

    </script>

</body>
</html>
